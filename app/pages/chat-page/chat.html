<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no">
  <title>Road Map</title>
  <link rel="stylesheet" href="./chat.css">
</head>
<body>
  <!-- Back Button (Image) -->
  <a href="javascript:history.back()" class="back-button">
    <img src="../../../public/img/back-arrow.png" alt="Back" />
  </a>

  <div class="lumachat-container">
    <!-- Left Column (Chat Section) -->
    <div class="column-left">
      <div class="box">
        <!-- Chat Section -->
        <div class="luma-box-chat">
          <h3>Chat with Luma</h3>
          <div id="chat-conversation" class="box-luma-conversation"></div>
          <!-- Container for the input box and send button -->
          <div class="chat-input-container">
            <input
              id="chat-input"
              class="luma-box-chat-input"
              type="text"
              placeholder="Type a message..."
            />
            <button id="send-message-button" class="send-message-button">
              <img src="../../../public/img/sendbutton.png" alt="Send Message" />
            </button>
          </div>
        </div>
      </div>
    </div>

    <!-- Middle Column (File Explorer & Path Search) -->
    <div class="column-middle">
      <div class="box">
        <div class="luma-box-chat">
          <!-- File and Folder Explorer -->
          <div id="fileExplorer" style="height: 500px; overflow-y: auto;">
            <div>Please choose a folder to start.</div> <!-- Initial state -->
          </div>
          <button id="chooseFolderBtn">Choose Folder</button> <!-- Choose Folder Button -->
          <button id="newNoteBtn" class="newnote" disabled>New Note</button> <!-- New Note Button -->

          <!-- Path Search Section -->
          <div class="path-search">
            <input type="text" id="pathInput" placeholder="Enter path..." />
            <button id="navigateToPathBtn">Go</button>
          </div>
        </div>
      </div>
    </div>

    <!-- Right Column (Note Editor) -->
    <div class="column-right">
      <div class="box">
        <div class="luma-box-chat">
          <h3>Note Editor</h3>
          <textarea id="editor" placeholder="Select a file to edit..." class="texteditor" readonly></textarea>
        </div>
      </div>
    </div>
  </div>

  <!-- Custom Context Menu -->
  <div id="contextMenu" style="display: none; position: absolute; background-color: white; border: 1px solid #ccc; box-shadow: 0 0 10px rgba(0, 0, 0, 0.1); z-index: 1000;">
    <ul style="list-style-type: none; padding: 0; margin: 0;">
      <li id="openFile">Open</li>
      <li id="renameFile">Rename</li>
      <li id="deleteFile">Delete</li>
    </ul>
  </div>

  <script>
    // Chat Section
    const chatEndpoint = "http://localhost:5000/chat";
    const chatConversation = document.getElementById("chat-conversation");
    const chatInput = document.getElementById("chat-input");
    const sendMessageButton = document.getElementById("send-message-button");
  
    function appendMessage(content, isUser, interactionKey = null) {
      const messageElement = document.createElement("div");
      messageElement.className = isUser ? "user-message" : "ai-message";
      messageElement.textContent = content;
  
      if (!isUser && interactionKey) {
        // Make the AI response editable on double-click
        messageElement.addEventListener("dblclick", () => {
          // Create an input field for editing the message
          const inputField = document.createElement("input");
          inputField.value = content;
          messageElement.textContent = ""; // Clear the original content
          messageElement.appendChild(inputField);
          inputField.focus();
  
          // Save the updated response on blur (when input loses focus)
          inputField.addEventListener("blur", () => {
            const updatedResponse = inputField.value.trim();
            if (updatedResponse !== content) {
              // Send the updated response to the backend
              fetch("http://localhost:5000/edit_response", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                  interaction_key: interactionKey,
                  updated_response: updatedResponse
                })
              })
              .then(response => response.json())
              .then(data => {
                if (data.success) {
                  // Update the message with the new response
                  messageElement.textContent = updatedResponse;
                } else {
                  alert("Failed to update response.");
                  messageElement.textContent = content; // Revert to original content
                }
              })
              .catch(error => {
                alert("Error: Unable to update response.");
                messageElement.textContent = content; // Revert to original content
              });
            } else {
              messageElement.textContent = content; // Revert to original content if no changes
            }
          });
        });
      }
  
      chatConversation.appendChild(messageElement);
      chatConversation.scrollTop = chatConversation.scrollHeight;
    }
  
    async function sendMessage() {
      const message = chatInput.value.trim();
      if (!message) return;
  
      appendMessage(message, true);
      chatInput.value = "";
  
      try {
        const response = await fetch(chatEndpoint, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ message })
        });
        const data = await response.json();
  
        if (data.response) {
          const interactionKey = data.interaction_key;  // Assuming interaction_key is sent from the backend
          appendMessage(data.response, false, interactionKey);
        } else {
          appendMessage("Error: No response from AI server.", false);
        }
      } catch (error) {
        appendMessage("Error: Unable to connect to AI server.", false);
      }
    }
  
    sendMessageButton.addEventListener("click", sendMessage);
    chatInput.addEventListener("keydown", (event) => {
      if (event.key === "Enter") sendMessage();
    });
  
    // File and Folder Explorer Section (unchanged)
    const { ipcRenderer } = require('electron');
    const fs = require('fs');
    const path = require('path');
    
    const editor = document.getElementById('editor');
    const newNoteBtn = document.getElementById('newNoteBtn');
    const fileExplorer = document.getElementById('fileExplorer');
    const chooseFolderBtn = document.getElementById('chooseFolderBtn');
    const contextMenu = document.getElementById('contextMenu');
    const pathInput = document.getElementById('pathInput');
    const navigateToPathBtn = document.getElementById('navigateToPathBtn');
    
    let currentFilePath = null;
    let currentDirectory = null;
    let selectedFileElement = null;
    let autoSaveTimeout = null; 
  
    editor.readOnly = true;
    newNoteBtn.disabled = true;
  
    navigateToPathBtn.addEventListener('click', () => {
      const enteredPath = pathInput.value.trim();
      if (enteredPath) {
        navigateToPath(enteredPath);
      } else {
        alert('Please enter a valid path.');
      }
    });
  
    pathInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        const enteredPath = pathInput.value.trim();
        if (enteredPath) {
          navigateToPath(enteredPath);
        } else {
          alert('Please enter a valid path.');
        }
      }
    });
  
    function navigateToPath(directoryPath) {
      fs.readdir(directoryPath, { withFileTypes: true }, (err, files) => {
        if (err) {
          alert('Error opening path: ' + err.message);
        } else {
          currentDirectory = directoryPath;
          loadDirectory(currentDirectory);
        }
      });
    }
  
    function loadDirectory(directoryPath) {
      if (!directoryPath) {
        alert('No folder selected. Please choose a folder first.');
        return;
      }
  
      currentDirectory = directoryPath;
      pathInput.value = currentDirectory;
  
      fs.readdir(directoryPath, { withFileTypes: true }, (err, files) => {
        if (err) {
          alert('Error reading directory: ' + err.message);
          return;
        }
  
        fileExplorer.innerHTML = '';
  
        const backButton = document.createElement('button');
        backButton.textContent = 'Back';
        backButton.style.marginBottom = '10px';
        backButton.addEventListener('click', navigateBack);
        fileExplorer.appendChild(backButton);
  
        const folderBreadcrumb = document.createElement('div');
        folderBreadcrumb.textContent = `Folder: ${directoryPath}`;
        folderBreadcrumb.classList.add('folder-breadcrumb');
  
        files.forEach(file => {
          const filePath = path.join(directoryPath, file.name);
          const fileElement = document.createElement('div');
          const fileText = document.createElement('span');
          fileText.textContent = file.name;
  
          fileElement.style.cursor = 'pointer';
          fileElement.classList.add(file.isDirectory() ? 'folder' : 'file');
          fileElement.appendChild(fileText);
  
          fileElement.addEventListener('click', () => {
            if (file.isDirectory()) {
              loadDirectory(filePath);
            } else {
              loadFile(filePath);
            }
          });
  
          fileExplorer.appendChild(fileElement);
        });
  
        editor.readOnly = false;
        newNoteBtn.disabled = false;
      });
    }
  
    function loadFile(filePath) {
      if (!filePath) return;
  
      fs.readFile(filePath, 'utf8', (err, data) => {
        if (err) {
          alert('Error opening file: ' + err.message);
        } else {
          editor.value = data;
          currentFilePath = filePath;
          editor.readOnly = false;
        }
      });
    }
  
    newNoteBtn.addEventListener('click', () => {
      if (!currentDirectory) {
        alert('No folder selected. Please choose a folder first.');
        return;
      }
  
      const newFileName = `new-note-${Date.now()}.md`;
      const newFilePath = path.join(currentDirectory, newFileName);
  
      fs.writeFile(newFilePath, '', (err) => {
        if (err) {
          alert('Error creating new file: ' + err.message);
        } else {
          loadDirectory(currentDirectory);
          loadFile(newFilePath);
        }
      });
    });
  
    chooseFolderBtn.addEventListener('click', () => {
      ipcRenderer.invoke('dialog:openDirectory').then((folderPath) => {
        if (folderPath) {
          currentDirectory = folderPath;
          loadDirectory(currentDirectory);
        }
      }).catch((err) => {
        alert('Error selecting folder: ' + err.message);
      });
    });
  </script>
  
  </body>
</html>
